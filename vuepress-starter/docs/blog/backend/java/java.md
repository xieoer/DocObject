# JAVA使用细节

<img src='/assets/img/logo.png'>

## 一．变量细节
#### 1）变量表示内存中的一个存储区域【不同的变量，类型不同，占用的空间大小不同】
#### 2）该区域有自己的名称和类型
#### 3）变量必须想声明后使用
#### 4）该区域的数据可以在同一个范围内不断变化
#### 5）变量在同一个作用域内不能重名
#### 6）变量=变量名+值+数据类型
<br />

## 二．整型细节
#### 1）java各整数类型有固定的范围和字段长度，不受具体os【操作系统】的影响，以保证java程序的可移植性
#### 2）java的整型常量默认为int型，声明long型常量须后加‘l’或‘L’
#### 3）java程序中变量常声明为int型，除非不足以表示大数，才使用long
#### 4）bit：计算机中的最小的储存单位。byte：计算机中基本储存单位，1byte=8bit。
<br />

## 三．浮点类型细节
#### 1）与整数类型类似，java浮点类型也有固定的范围和字段长度，不受具体os的影响
#### 2）Java的浮点类型常量默认为double型，声明float型常量须后加‘f’或‘F’
#### 3）浮点型常量有两种表示形式
#### 十进制形式：5.12
#### 科学计数法形式：5.12e2[ ]
#### 4）通常情况下，应该使用double型，因为它比float型更精确
<br />

## 四．字符型细节
#### 1）字符常量是用单引号（‘’）括起来的单个字符
#### 2）Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：‘\n’换行符
#### 3）在java中，char的本质是一个整数，在输出时，unicode码对应的字符
#### 4）可以直接给char赋一个整数，在输出时，是unicode码对应的字符
#### 5）Char类型也可以进行运算，相当于一个整数，因为它都对应有unicode码
<br />

## 五．基本类型转换细节
#### 1）有多种类型的数据混合运算时，系统首先自动将所有数据类型转换成容量最大的那种数据类型，然后再进行计算
#### 2）当我们把精度（容量）大的数据类型赋值给精度小的数据类型时，就会报错，反之就会进行自动类型转换
#### 3）（byte，short）和char之间不会相互自动转换
#### 4）Byte，short，char他们三者可以计算，在计算时首先转换为int类型
#### 5）Boolean不参与转换
#### 6）自动提升原则：表达式结果的类型自动提升为操作数中最大的类型
<br />

## 六．强制类型转换细节
#### 1）当进行数据的大小，从大——>小，就需要使用强制转换
#### 2）强制符号只针对于最近的操作数有效，往往会使用小括号提升优先级
#### 3）Char类型可以保存int的常量值，但不能保存int的变量值，需要强制转换
#### 4）Byte和short类型在进行运算时，当做int类型处理
<br />

## 七．基本数据类型和String类型的转换
#### 1）基本类型转String类型
#### 将基本类型的值+””即可
#### 2）String类型转基本数据类型
#### 通过基本类型的包装类调用parseXX方法即可
#### 3）在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据
#### 4）如果格式不正确，就会抛出异常，程序就会终止
<br />

## 八．原码，反码，补码
#### 1）二进制的最高位是符号位：0表示正数，1表示负数
#### 2）正数的原码，反码，补码都一样（三码合一）
#### 3）负数的反码=它的原码符号位不变，其它位取反（0-->1,1-->0）
#### 4）负数的补码=它的反码+1，负数的反码=负数的补码-1
#### 5）0的反码，补码都是0
#### 6）Java没有无符号数，换言之，java中的数都是有符号的
#### 7）在计算机运算的时候，都是以补码的方式来运算的
#### 8）当我们看运行结果的时候，要看他的原码
<br />

## 九．Switch的细节
#### 1）表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int
#### 2）Switch（表达式）中表达式的返回值必须是：（byte,short,int,char,enum,string）
#### 3）Case子句中的值必须是常量，而不能是变量
#### 4）Default子句是可选的，但没有匹配case时，执行default
#### 5）Break语句用来在执行完一个case分支使程序跳出switch语句块，如果没有写break，程序会按顺序执行到switch的结尾
<br />

## 十．For的细节
#### 1）循环条件是返回一个布尔值的表达式
#### 2）For（；循环条件；）中的初始化和变量的迭代可以写在别的地方，但是两边分号不能省
#### 3）循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开
<br />

## 十一．Break，continue的细节
#### 1）Break和countinue语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块
<br />
 
## 十二．数组的细节
#### 1）数组是多个相同类型数据的组合，实现对这些数据的统一管理
#### 2）数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用
#### 3）数组创建后，如果没有赋值，是默认值int 0，shrot 0，long 0，float 0，double 0.0，char \u0000，boolean false，string null
#### 4）使用数组的步骤1.声明数组并开辟空间  2.给数组各个元素赋值  3. 使用数组
#### 5）数组下标是从0开始的
#### 6）数组下标必须在指定范围内使用
#### 7）数组属于引用类型，数组型数据是对象（object）
<br />
 
## 十三．二维数组细节
#### 1）一维数组的声明方式有：
#### int[ ] x 或者 int x[ ]
#### 2）二维数组的声明方式有：
#### int[ ][ ] y 或者 int[ ] y[ ] 或者 int y[ ][ ]
#### 3）二维数组实际上是由多个一维数组组成的，他的各个一维数组的长度可以相同，也可以不相同
<br />

## 十四．成员方法细节
#### 1）一个方法最多有一个返回值
#### 2）返回类型可以为任意类型，包含基本类型或引用类型
#### 3）如果方法要求有返回数据类型，则方法体中最后的执行语句必须是return值；而且要求返回值类型必须和return的值类型一致或兼容
#### 4）如果方法是void，则方法体中可以没有return语句，或者只写return
#### 5）一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开
#### 6）参数类型可以为任意类型，包含基本类型或引用类型
#### 7）调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数
#### 8）方法定义时的参数称为形式参数；方法调用时的参数称为实际参数，形参与实参类型，个数，顺序要一致
#### 9）方法体里面写完成功能的具体语句，可以为输入，输出，变量，运算，分支，循环，方法调用，但里面不能再定义方法
#### 10）同一个类中的方法调用：直接调用即可
#### 11）跨类中的方法A类调用B类方法：需要通过对象名调用。
#### 12）跨类的方法调用和方法的访问修饰符相关
<br />

## 十五．递归细节
#### 1）执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
#### 2）方法的局部变量是独立的，不会相互影响
#### 3）如果方法中使用的是引用类型变量（数组，对象），就会共享该引用类型的数据
#### 4）递归必须向退出递归的条件逼近，否则就是无限递归
#### 5）当一个方法执行完毕，或遇到return，就会返回，遵守谁调用，九将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕
<br />
 
## 十六．方法重载细节
#### 1）方法名必须相同
#### 2）参数列表必须不同（参数类型，参数个数或参数顺序，至少有一个不同，参数名无要求）
#### 3）返回类型无要求
<br />

## 十七．可变参数细节
#### 1）可变参数的实参可以为0个或任意多个
#### 2）可变参数的实参可以为数组
#### 3）可变参数的本质就是数组
#### 4）可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
#### 5）一个形参列表中只能出现一个可变参数
<br />

## 十八．作用域细节
#### 1）属性和局部变量可以重名，访问时遵循就近原则
#### 2）在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名
#### 3）属性的生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量生命周期短，伴随着它的代码块的执行创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。
#### 4）全局变量可以被本类使用，或者其他类使用（通过对象调用）；局部变量只能在本类对应的方法中使用
#### 5）全局变量/属性可以加修饰符；局部变量不可以加修饰符
<br />

## 十九．构造器细节
#### 1）一个类可以定义多个不同的构造器，即构造器重载
#### 2）构造器和类名相同
#### 3）构造器没有返回值
#### 4）构造器是完成对象的初始化，并不是创建对象
#### 5）在创建对象时，系统自动的调用该类的构造方法
#### 6）如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造方法
#### 7）一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显示的定义一下
#### 即：构造器名( ){}
<br />

## 二十. this使用细节
#### 1）this关键字可以用来访问本类的属性，方法和构造器
#### 2）this用于区分当前类的属性和局部变量
#### 3）访问成员方法的语法：this.方法名（参数列表）
#### 4）访问构造器的语法：this（参数列表）；注意只能在构造器中使用
#### 5）this不能在类定义的外部使用，只能在类定义的方法中使用
<br />

## 二十一. IDEA快捷键（常用）
#### 1）删除当行：ctrl+D
#### 2）复制当行到下行：ctrl+alt+向下键
#### 3）补全代码：alt+/
#### 4）添加注释和取消注释：ctrl+/
#### 5）导入改行需要的类：alt+enter
#### 6）快速格式化代码：ctrl+shift+L
#### 7）快速运行程序（自定义）：alt+R
#### 8）生成构造方法：alt+insert
#### 9）查看一个类的层级关系：ctrl+H
#### 10）定位方法所属类：ctrl+B
#### 11）自动分配变量名：在后面加.var
<br />

## 二十二. 包的细节
#### 1）package的作用是声明当前类所在的包，需要放在类的最上面，一个类只多只有一句package
#### 2）Import指令，位置在package的下边，在类定义的上边，可以有多句，且没有顺序要求
<br />

## 二十三. 访问修饰符细节
#### 1）public（同类，同包，子类，不同包） protected（同类，同包，子类） 默认（同类，同包） private（同类）
#### 2）修饰符可以用来修饰类中的属性，成员方法，以及类
#### 3）只有默认的和public才能修饰类，并且遵循上述访问权限特点
#### 4）成员方法的访问规则与属性完全一样
<br />

## 二十四. 继承使用细节
#### 1）代码的复用性提高了
#### 2）代码的拓展性和维护性提高了
#### 3）子类继承了所有的属性和方法，但是私有属性和方法 不能在子类直接访问，要通过公共的方法去访问
#### 4）子类必须调用父类的构造器，完成父类的初始化
#### 5）当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类构造器中使用super去指定使用父类的哪个构造器完成 父类的初始化工作，否则编译不通过
#### 6）如果希望指定去调用父类的某个构造器，则显示的调用一下：super(参数列表)
#### 7）Super在使用时，需要放在构造器第一行
#### 8）Super( )和this( )都放在构造器第一行，因此这两个方法不能共存在一个构造器
#### 9）Java所有类都是object类的子类
#### 10）父类构造器的调用不限于直接父类！将一直往上追溯到object类（顶级父类）
#### 11）子类最多只能继承一个父类（直接继承），即java中是单继承机制
#### 12）不能滥用继承，子类和父类之间必须满足is-a的逻辑关系
         例如：jack is a person  则jack可以继承person
<br />         

## 二十五.  super使用细节
#### 1）调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）
#### 2）当子类有和父类的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super，this，直接访问的效果是一样的
#### 3）super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则
<br />

## 二十六.  this与super比较   
| No.   | 区别点       | This                                            |Super
| ----- |:-----------:|:------------------------------------------------|:-----------------|
|  1    | 访问属性     |访问本类中的属性，如果本类没有此属性则从父类中继续查找|访问父类中的属性
|  2    | 调用方法     |访问本类中的方法，如果本类没有此方法则从父类继续查找  |直接访问父类中的方法
|  3    | 调用构造器   |调用本类构造器，必须放在构造器的首行                 |调用父类构造器，必须放在子类构造器的首行
|  4    | 特殊         |表示当前对象                                      |子类中访问父类对象
<br />

## 二十七. 方法重写（override）的细节
#### 1）子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样
#### 2）子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类
#### 3）子类方法不能缩小父类方法的访问权限
<br />

## 二十八. 方法重写和方法重载的比较
|名称            |发生范围 |方法名	 |参数列表	                   |返回类型	                                             |修饰符
| ------------- |:-------:|:------|:------------------------------|:------------------------------------------------------|:----------------------------|
|重载（overload）|本类	  |必须一样|类型，个数或者循序至少有一个不同  |无要求	                                               |无要求
|重写（override）|父子类	  |必须一样|相同	                        |子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类|子类方法不能缩小父类方法访问范围
<br />

## 二十九. 对象的多态
#### 1）一个对象的编译类型和运行类型可以不一致
#### 2）编译类型在定义对象时就确定了，不能改变
#### 3）运行类型是可以改变的
#### 4）编译类型看定义时=号的左边，运行类型看=号的右边
<br />

## 三十. 向上转型
#### 1）本质：父类引用子类的对象
#### 2）语法：父类类型 引用名 =  new 子类类型
#### 3）特点：编译类型看左边，运行类型看右边。
#### 4）可以调用父类中的所有成员（遵循访问权限），不能调用子类中特有的成员；最终运行效果看子类的具体是实现
<br />

## 三十一. 向下转型
#### 1）语法：子类类型 引用名 =（子类类型）父类引用；
#### 2）只能强转父类的引用，不能强转父类的对象
#### 3）要求父类的引用必须指向的是当前目标类型的对象
#### 4）可以调用子类中所有的成员
<br />

## 三十二. 动态绑定机制
#### 1）当调用对象方法的时候，该方法会和给对象的内存地址/运行类型绑定
#### 2）当调用对象属性时，没有动态绑定机制，哪里声明，使用哪里的属性
<br />

## 三十三.类变量使用细节
#### 1）什么时候使用类变量：当我们需要让某个类的所有对象都共享一个变量时
#### 2）类变量与实例变量的区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的
#### 3）加上static称为类变量或静态变量
#### 4）类变量可以通过 类名.类变量名/对象名.类变量名 来访问
<br />

## 三十四.代码块细节
#### 1）static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次，如果是普通代码块，每创建一个对象就执行
#### 2）类什么时候加载：①创建对象实例时②创建子类对象实例，父类也会加载③使用类的静态成员时（静态属性，静态方法）
#### 3）普通代码块，在创建对象实例时，会被隐式调用，被创建一次，就调用一次，如果只是使用类的静态成员时，普通代码块并不会执行
#### 4）创建一个对象时，在一个类调用顺序是：
#### ①调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果多个静态代码块和多个静态变量初始化，则按它们定义的顺序调用）
#### ②调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用优先级一样，如果多个普通代码块和多个普通变量初始化，则按它们定义的顺序调用）
#### ③调用构造方法
#### 5）构造方法的最前面其实隐含了super（）和调用普通代码块
#### 6）创建一个子类对象时，类调用顺序：
     ①父类静态代码块和静态属性（优先级一样）
     ②子类静态代码块和静态属性（优先级一样）
     ③父类的普通代码块和普通属性初始化（优先级一样）
     ④父类的构造方法
     ⑤子类的普通代码块和普通属性初始化（优先级一样）
     ⑥子类的构造方法
<br />

## 三十五.final关键字细节
#### 1）final修饰的属性又叫常量，一般用XXX_XXX来命名
#### 2）final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：①定义时②在构造器中③在代码块中
#### 3）如果final修饰的属性是静态的，则初始化的位置只能是：①定义时②在静态代码块
#### 4）final类不能继承，但可以实例化对象
#### 5）如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承
#### 6）一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法
#### 7）final不能修饰构造方法
#### 8）final和static往往搭配使用，效率更高
#### 9）包装类（Integer，Double，Float，Boolean等都是final类），String也是final类
<br />

## 三十六.抽象类细节
#### 1）抽象类不能被实例化
#### 2）抽象类不一定包含abstract方法，也就是说抽象类可以没有abstract方法
#### 3）一旦类包含了abstract方法，则这个类必须声明为abstract
#### 4）abstract只能修饰类和方法，不能修饰属性和其他的
#### 5）抽象类可以有任意成员（因为抽象类还是类），比如：非抽象方法，构造器，静态属性等等
#### 6）抽象方法不能有主体，即不能实现
#### 7）如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类
<br />

## 三十七.接口细节
#### 1）接口不能被实例化
#### 2）接口中所有的方法是public方法，接口中的抽象方法，可以不用abstract修饰
#### 3）一个普通类实现接口，就必须将该接口所有的方法实现
#### 4）抽象类实现接口，可以不用实现接口的方法
#### 5）一个类同时可以实现多个接口
#### 6）接口中的属性，只能是final的，而且是public static final 修饰
#### 7）接口中的属性的访问形式：接口名.属性名
#### 8）一个接口不能继承其他的类，但可以继承多个别的接口
#### 9）接口的修饰符只能是public和默认，这点和类的修饰符是一样的
#### 10）接口也有多态特性以及多态传递
<br />

## 三十八.内部类
#### 1）类的五大成员：属性，方法，构造器，代码块，内部类
#### 2）匿名内部类既是一个类的定义，同时它本身也是一个对象，因此，它既有定义类的特征，也有创建对象的特征
#### 3）可以直接访问外部类的所有成员，包含私有的
#### 4）不能添加访问修饰符，因为它的地位就是以恶搞局部变量
#### 5）作用域：仅仅在定义它的方法或者代码块中
#### 6）外部其他类不能访问匿名内部类（因为匿名内部类是一个局部变量）
#### 7）如果外部类和内部类的成员重名，内部类访问时遵循就近原则，如果要访问外部类的成员，则用（外部类名.this.成员）去访问
#### 8）成员内部类相当于外部类的一个成员，能被外部类中的方法使用，也能够在其他外部类中访问
<br />

## 三十九.枚举类使用细节
#### 1）使用枚举关键字后，就不能在继承其他类了，因为enum会隐式继承Enum
#### 2）枚举类和普通类一样，可以实现接口
<br />

## 四十.4个元注解
#### 1）@Target：注解的作用目标
#### @Target(ElementType.TYPE)                         //接口、类、枚举、注解
#### @Target(ElementType.FIELD)                        //字段、枚举的常量
#### @Target(ElementType.METHOD)                       //方法
#### @Target(ElementType.PARAMETER)                    //方法参数
#### @Target(ElementType.CONSTRUCTOR)                  //构造函数
#### @Target(ElementType.LOCAL_VARIABLE)               //局部变量
#### @Target(ElementType.ANNOTATION_TYPE)              //注解
#### @Target(ElementType.PACKAGE)                      //包
#### @Target(ElementType.TYPE_PARAMETER)               //类型参数
#### @Target(ElementType.TYPE_USE)
#### 2）@Retention：注解的保留位置
#### @Retention(RetentionPolicy.SOURECE)  //注解仅存在于源码中，在class字节码文件中不包含
#### @Retention(RetentionPolicy.CLASS)    // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，
#### @Retention(RetentionPolicy.RUNTIME)   注解会在class字节码文件中存在，在运行时可以通过反射获取到
#### 3）@Document：说明该注解将被包含在javadoc中
#### 4）@Inherited：说明子类可以继承父类中的该注解
<br />

## 四十一.异常
#### 1）异常分为两大类：运行时异常和编译时异常
#### 2）运行时异常，编译器不要求强制处置的异常，一般是指编译时的逻辑错误，是程序员应该避免其出现的异常
#### 3）对于运行时异常可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响
#### 4）编译时异常，是编译器要求必须处理的异常
#### 5）子类重写父类的方法时，所抛出的异常类型要么和父类抛出的异常一致，要么是父类抛出异常类型的子类型
#### 6）在throws过程中，如果有方法try-catch，就相当于处理异常，就不必throws
<br />

## 四十二.String , StringBuffer , StringBuilder选择
#### 1）如果字符串存在大量的修改工作，一般使用StringBuffer或StringBuilder
#### 2）如果字符串存在大量的修改操作，并且在单线程的情况下，使用StringBuilder
#### 3）如果字符串存在大量的修改操作，并且在多线程的情况下，使用StringBuffer
#### 4）如果字符串很少修改，被多个对象引用，使用String
<br />

## 四十三.ArrayList和LinkedList比较
#### 1）ArrayList对数据进行修改和查找的效率更高，它的底层是一个可变数组
#### 2）LinkedList对数据进行插入和删除的效率更高，它的底层是一个双向链表
<br />

## 四十四.HashSet细节（底层HashMap）
#### 1）HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（0.75）（loadFator）=12
#### 2）如果table数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是32*0.75 = 24，依此类推
#### 3）在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8）并且table的大小>=MIN_TREEIFY_CAPACITY（默认为64），就会进行树化（红黑树），否则仍然采用数组扩容机制
<br />

## 四十五.Map接口和常用方法
#### 1）Map和Collection并列存在，用于保存具有映射关系的数据：Key-Value
#### 2）Map中的key和value可以是任意引用类型的数据，会封装到HashMap$Node对象中
#### 3）Map中的key不允许重复
#### 4）Map中的value可以重复
#### 5）Map中的key可以为null，value也可以为null，但是key为null只能有一个
#### 6）常用String类作为Map的key
#### 7）Key和value之间存在单向一对一关系，通过指定的key中能找到对应的balue
#### 8）一对k-y放在一个Node中
<br />

## 四十六.开发中集合使用
#### 1）先判断存储的类型（一组对象【单列】，一组键值对【双列】）
#### 2）一组对象【单列】：Collection接口
#### A.允许重复：List
#### a.增删多：LinkedList	（底层维护了一个双向链表）
#### b.改查多：ArrayList （底层维护Object类型的可变数组）
#### B.不允许重复：Set
#### a.无序：HashSet （底层是HashMap，维护一个哈希表，即数组+链表+红黑树）
#### b.排序：TreeSet （插入顺序和取出顺序一致，LinkedHashSet，维护数组+双向链表）
#### 3）一组键值对：Map
#### 键无序：HashMap（底层是：哈希表，数组+链表+红黑树）
#### 键排序：TreeMap（键插入和取出顺序一致，LinkedHashMap）
<br />

## 四十七.泛型的使用
#### 1）给泛型指向数据类型的时候，不能是基本数据类型
#### 2）在指定泛型的具体类型后，可以传入该类型或该子类类型
#### 3）泛型使用形式①ArrayList\<Integer\> list = new ArrayList<>()
#### 4）②ArrayList\<Integer\> list = new ArrayList\<Integer\>()
#### 5）ArrayList list = new ArrayList()等价于
#### 6）ArrayList\<Object\> list = new ArrayList<>()
#### 7）自定义泛型类时，静态方法和静态属性不能使用泛型
#### 8）自定义泛型类时，不能new一个泛型类
#### 9）自定义泛型接口语法：interface\<T，R....\>{}
#### 10）自定义泛型接口在实现或继承该接口是会确定泛型类型
#### 11）自定义泛型方法时，泛型方法可以定义在非泛型类中
#### 12）当泛型方法被调用时，类型会确定
#### 13）泛型方法语法:修饰符\<T,R....\> 返回类型 方法名（参数）{}
#### 14）修饰符后面没有\<T,R....\>的不是泛型方法，例如：public void f( E e)不是泛型方法，只是使用了泛型
<br />
 
## 四十八.泛型的继承和通配符
#### 1）泛型没有继承性，例如List\<Object\> list = new ArrayList\<String\>( )是错的
#### 2）<?> :支持任意泛型类型
#### 3）<? extends A>:支持A类以及A类的子类，规定了泛型的上限
#### 4）<? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限
<br />

## 四十九.线程的细节
#### 1）启动线程时调用start方法，底层会自动创建新的线程，并调用run方法，run就是一个简单方法的调用，不会启动新的线程
#### 2）interrupt，中断线程，但并没有真正的结束线程，一般用于中断正在休眠的线程
#### 3）sleep，线程的静态方法，使当前线程休眠
#### 4）setPriority，设置优先级
#### 5）yield，线程礼让，让出cpu，让其他线程执行，但礼让时间不确定，所以也不一定礼让成功
#### 6）join，线程的插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务
<br />

## 五十.线程状态
#### 1）new状态，尚未启动的线程       
#### 2）runnable状态，在java虚拟机中执行的线程处于此状态（分为ready和running）
#### 3）blocked状态，被堵塞等待监控器锁定的线程处于此状态        
#### 4）waiting状态，正在等待另一个线程执行特定动作的线程处于此状态
#### 5）timedwaiting状态，正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
#### 6）terminated状态，以退出的线程
<img src='/assets/img/xiancheng.png'>
<br />

## 五十一.线程同步机制（synchronized）
#### 1）在多线程中，一些敏感的数据不能同时被多个线程访问，此时就要使用同步访问技术，保证数据在任意时刻，最多只被一个线程访问，以确保数据完整性
#### 2）同步方法如果没有使用static修饰，默认锁对象为this
#### 3）如果方法使用static修饰，默认锁对象为：当前类.class
#### 4）死锁，多个线程占用了对方的锁的资源，但不肯相让
#### 5）释放锁：①当前线程的同步方法，同步代码块执行结束
#### 	 ②当前线程的同步方法，同步代码块的方法中遇到break，return
#### 	 ③当前线程的同步方法，同步代码块的方法中出现Error或Exception导致异常结束
#### 	 ④当前线程在同步方法，同步代码块的方法中执行了wait( )方法，当前线程暂停，释放锁
#### 6）不会释放锁：①当前线程在执行同步方法，同步代码块的方法，程序调用Thread.sleep（）,Thread.yield（）方法
#### 	 ②执行同步代码块时，其他线程调用了该线程的suspend（）方法		将该线程挂起，该线程不会释放锁（suspend方法不推荐使用）
<br />

## 五十二.IO流
#### 1）按操作数据不同分为：字节流（一字节8bit，通常用来处理二进制文件），字符流（按字符，通常用来处理文本文件）
#### 2）按数据流向不同分为：输入流（InputStream，Reader），输出流（Outputstream，Writer）
#### 3）按流的角色不同分为：节点流，处理流/包装流
<img src='/assets/img/IOliu.png'>
<br />
 
## 五十二.序列化和反序列化
#### 1）序列化是保存数据时，保存数据的值和数据类型
#### 2）分序列化就是恢复数据时，恢复数据的值和数据类型
#### 3）需要让某个对象支持序列化机制，则必须让其类是可序列化的，该类必须实现两个接口中的一个，Serializable（这是一个标记接口没有方法），Externaliazble（该接口有方法需要实现，一般不选用）
<br />


